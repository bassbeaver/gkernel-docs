{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gkernel documentation Gkernel is simple event based web framework written with Go. Example of application build with Gkernel: https://github.com/bassbeaver/gkernel-skeleton You can use this skeleton project for acquaintance with Gkernel or to start building your web application.","title":"Introduction"},{"location":"#gkernel-documentation","text":"Gkernel is simple event based web framework written with Go. Example of application build with Gkernel: https://github.com/bassbeaver/gkernel-skeleton You can use this skeleton project for acquaintance with Gkernel or to start building your web application.","title":"Gkernel documentation"},{"location":"about/","text":"Gkernel framework: https://github.com/bassbeaver/gkernel Example application build with Gkernel: https://github.com/bassbeaver/gkernel-skeleton Developed just for fun by bassbeaver .","title":"About"},{"location":"v0.4/1_main-concepts/","text":"Basic entities Main idea of Gkernel framework is to organize request processing flow which is: controlled by events processed by services, and services are managed by Service Container Framework determines next main entities for request processing: Request - represents an HTTP request received by a server. Gkernel uses standard net/http Request type. Response - represents result of request processing, that should be sent to user. Controller - function that receive request object and have to return response object. Event - some event that happened during request processing (or during life of the whole application). This events are dispatched by framework. Event listener - function that receive and process events (dispatched by framework) and can affect request processing flow. Configuration Gkernel uses yaml files to describe application configuration. Path to folder, containing config files, should be passed to Kernel constructor. Config files describe application parameters (like port to listen on, environment etc.), routes, services and event listeners. Under the hood to work with config files Gkernel uses viper library. Viper can read json , toml , yaml , yml , properties , props , prop , hcl files, so, in fact, any of that file types can be used as configuration files for Gkernel. But we suggests to use yaml . While reading config path (directory) Gkernel reads any allowed (that Viper can read) file from that directory and treats it like configuration file. Therefore it is recommended to store config files in separate folder and not mix config files with other files to avoid erroneous read of non-config file. Request lifecycle Request processing cycle (also it can be called request lifecycle) has next main parts: Framework receives request and performs routing to determine controller for request processing. If required route not exists - framework creates NotFoundHttpError and dispatches RuntimeError event. RequestReceived event is being dispatched. If listeners for that event returned response object - framework goes to p.5. Controller starts. RequestProcessed event is being dispatched. ResponseBeforeSend event is being dispatched. Framework sends response to user. RequestTermination event is being dispatched. Notice: RequestTermination is dispatched in separate goroutine in order not to delay response sending to user. If some panic occurs during request processing framework recovers it and dispatches RuntimeError . Services and DI container Service is a logical concept of some complete component or functionality block inside a program with a purpose that different clients can reuse it for different purposes. Mostly all parts of application can be referenced as services. Controller is a service, event listener is a service etc. As one of it's main parts Gkernel framework has DI container. It used for managing dependencies of application components (services) and performing dependency injection. (If you are not familiar with Dependency injection concept, you can read this article ). As DI container bassbeaver/gioc library is used.","title":"Main concepts"},{"location":"v0.4/1_main-concepts/#basic-entities","text":"Main idea of Gkernel framework is to organize request processing flow which is: controlled by events processed by services, and services are managed by Service Container Framework determines next main entities for request processing: Request - represents an HTTP request received by a server. Gkernel uses standard net/http Request type. Response - represents result of request processing, that should be sent to user. Controller - function that receive request object and have to return response object. Event - some event that happened during request processing (or during life of the whole application). This events are dispatched by framework. Event listener - function that receive and process events (dispatched by framework) and can affect request processing flow.","title":"Basic entities"},{"location":"v0.4/1_main-concepts/#configuration","text":"Gkernel uses yaml files to describe application configuration. Path to folder, containing config files, should be passed to Kernel constructor. Config files describe application parameters (like port to listen on, environment etc.), routes, services and event listeners. Under the hood to work with config files Gkernel uses viper library. Viper can read json , toml , yaml , yml , properties , props , prop , hcl files, so, in fact, any of that file types can be used as configuration files for Gkernel. But we suggests to use yaml . While reading config path (directory) Gkernel reads any allowed (that Viper can read) file from that directory and treats it like configuration file. Therefore it is recommended to store config files in separate folder and not mix config files with other files to avoid erroneous read of non-config file.","title":"Configuration"},{"location":"v0.4/1_main-concepts/#request-lifecycle","text":"Request processing cycle (also it can be called request lifecycle) has next main parts: Framework receives request and performs routing to determine controller for request processing. If required route not exists - framework creates NotFoundHttpError and dispatches RuntimeError event. RequestReceived event is being dispatched. If listeners for that event returned response object - framework goes to p.5. Controller starts. RequestProcessed event is being dispatched. ResponseBeforeSend event is being dispatched. Framework sends response to user. RequestTermination event is being dispatched. Notice: RequestTermination is dispatched in separate goroutine in order not to delay response sending to user. If some panic occurs during request processing framework recovers it and dispatches RuntimeError .","title":"Request lifecycle"},{"location":"v0.4/1_main-concepts/#services-and-di-container","text":"Service is a logical concept of some complete component or functionality block inside a program with a purpose that different clients can reuse it for different purposes. Mostly all parts of application can be referenced as services. Controller is a service, event listener is a service etc. As one of it's main parts Gkernel framework has DI container. It used for managing dependencies of application components (services) and performing dependency injection. (If you are not familiar with Dependency injection concept, you can read this article ). As DI container bassbeaver/gioc library is used.","title":"Services and DI container"},{"location":"v0.4/2_configuration/","text":"Gkernel uses yaml files to describe application configuration. Path to folder containing these files should be passed to Kernel constructor. Config files describe application parameters (like port to listen on, environment etc.), routes, services and event listeners. Simple example: import ( \"github.com/bassbeaver/gkernel\" ) ... var configPath string configPath = \"/path/to/config\" kernelObj, kernelError := gkernel.NewKernel(configPath) It's a good idea to get this path as program argument. This approach is used in gkernel skeleton application : import ( \"flag\" \"fmt\" \"github.com/bassbeaver/gkernel\" kernelResponse \"github.com/bassbeaver/gkernel/response\" \"net/http\" \"net/http/pprof\" \"os\" ) ... // --- Processing application's arguments and flags flags := flag.NewFlagSet(\"flags\", flag.PanicOnError) configPathFlag := flags.String(\"config\", \"\", \"Path to config file\") flagsErr := flags.Parse(os.Args[1:]) if nil != flagsErr { panic(flagsErr) } // --- Creating application Kernel var configPath string if \"\" == *configPathFlag { curBinDir, curBinDirError := os.Getwd() if curBinDirError != nil { fmt.Println(\"Failed to determine path to own binary file\") panic(curBinDirError) } configPath = curBinDir + \"/config\" } else { configPath = *configPathFlag } kernelObj, kernelError := gkernel.NewKernel(configPath) if nil != kernelError { panic(kernelError) } Code above searches for program argument config passed to application during its start, if no argument found it tries to find config directory in its working directory and panics if failed to locate config files path. For example, if you build you app binary to /etc/gkernel-app and put your config files to /configs/gkernel-app-config it could be like: /etc/gkernel-app -config /configs/gkernel-app-config Configuration file overview Configuration file has next root keys: http_port app_env templates_path services routing event_listeners parameters http_port Determines on what port application would be listening for requests. app_env Determines current application's environment. This is just a flag thet signals to application's code in what regime it is running. Typically application can have two environments: dev and prod , but you are free to use as many environments as you want. templates_path Gkernel uses go html/template package as a template engine to render pages. This templates are parsed during Kernel startup and templates_path key determines where Kernel should search for your templates. services services block describes all services in the application. Reading this block Kernel learns what services should be registered in DI container. Each service should have alias and arguments. Example: services: Sessions: arguments: [\"sid\", \"@SessionsRedisConnection\"] Where Sessions are service alias and arguments: [\"sid\", \"@SessionsRedisConnection\"] indicates that Sessions service factory requires two arguments and first argument is just simple string with value sid and second argument should be a pointer to the SessionsRedisConnection service (this SessionsRedisConnection service have also to be described in config file). I want to bring your attention to that config file only describes services and service-factories arguments, and you have to register that factories in your application code. For more information about services and DI container see \"Services and DI container\" section. routing This block describes routes provided by application. A route is a map from a URL path to the program logic, designed to process requests to that URL (we call that logic - Controller). Routing block has next sub-blocs: * routes - list of available routes * event_listeners - request-level event listeners common for all routes Route description looks like: IndexController:privatePage: url: \"/private-page\" methods: [\"GET\"] controller: \"IndexController:PrivatePage\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectToLoginIfNotAuthenticated\", priority: 41} Where: IndexController:privatePage - route name url - url or the route, url can contain parameters: \"/some-page/:param1\" methods - list of HTTP methods allowed for this route controller - controller to process request matched to this route. IndexController is the service alias in DI container and PrivatePage is the name of method to be called to process request. event_listeners - list of request-level event listeners for this route, for more information see \"Events and listeners\" section. Whole routing block can look like: routing: routes: IndexController:index: url: \"/\" methods: [\"GET\"] controller: \"IndexController:Index\" IndexController:loginPage: url: \"/login\" methods: [\"GET\"] controller: \"IndexController:LoginPage\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectIfAuthenticated\", priority: 41} event_listeners: - {event: kernelEvent.RequestReceived, listener: \"RequestLoggerSetter:CreateLogger\", priority: 15} - {event: kernelEvent.RequestTermination, listener: \"RequestLoggerSetter:CloseLogger\", priority: 100} We can see here two routes IndexController:index and IndexController:loginPage . Routes have two common event listeners ( RequestLoggerSetter:CreateLogger , RequestLoggerSetter:CloseLogger ), this listeners will run at every request. Also IndexController:loginPage has AuthService:RedirectIfAuthenticated listener, this listener will run only during GET /login request. event_listeners This block describes application level event listeners. Can look like: event_listeners: - {event: kernelEvent.ApplicationLaunched, listener: \"SessionsMiddleware:InitRedisConnection\", priority: 10} - {event: kernelEvent.ApplicationTermination, listener: \"SessionsMiddleware:CloseRedisConnection\", priority: 10} For more information see \"Events and listeners\" section. parameters This block is simple key-value storage for some application parameters that can change in different environments or run cases. For example, you need some timeout value for some process and you want this timeout be 30 sec on prod server and 60 sec on dev server. You need to pass this value to corresponding service (in services configuration block). In such case you can define timeout_value parameter, use it by name as service-factory parameter in services section and it's will be stored in parameters section. So for different servers you should only change parameters section of config file. Example part of config file for prod server: services: SomeService: arguments: [\"#timeout_value\"] parameters: timeout_value: 30 Example part of config file for dev server: services: SomeService: arguments: [\"#timeout_value\"] parameters: timeout_value: 60","title":"Configuration"},{"location":"v0.4/2_configuration/#configuration-file-overview","text":"Configuration file has next root keys: http_port app_env templates_path services routing event_listeners parameters","title":"Configuration file overview"},{"location":"v0.4/2_configuration/#http_port","text":"Determines on what port application would be listening for requests.","title":"http_port"},{"location":"v0.4/2_configuration/#app_env","text":"Determines current application's environment. This is just a flag thet signals to application's code in what regime it is running. Typically application can have two environments: dev and prod , but you are free to use as many environments as you want.","title":"app_env"},{"location":"v0.4/2_configuration/#templates_path","text":"Gkernel uses go html/template package as a template engine to render pages. This templates are parsed during Kernel startup and templates_path key determines where Kernel should search for your templates.","title":"templates_path"},{"location":"v0.4/2_configuration/#services","text":"services block describes all services in the application. Reading this block Kernel learns what services should be registered in DI container. Each service should have alias and arguments. Example: services: Sessions: arguments: [\"sid\", \"@SessionsRedisConnection\"] Where Sessions are service alias and arguments: [\"sid\", \"@SessionsRedisConnection\"] indicates that Sessions service factory requires two arguments and first argument is just simple string with value sid and second argument should be a pointer to the SessionsRedisConnection service (this SessionsRedisConnection service have also to be described in config file). I want to bring your attention to that config file only describes services and service-factories arguments, and you have to register that factories in your application code. For more information about services and DI container see \"Services and DI container\" section.","title":"services"},{"location":"v0.4/2_configuration/#routing","text":"This block describes routes provided by application. A route is a map from a URL path to the program logic, designed to process requests to that URL (we call that logic - Controller). Routing block has next sub-blocs: * routes - list of available routes * event_listeners - request-level event listeners common for all routes Route description looks like: IndexController:privatePage: url: \"/private-page\" methods: [\"GET\"] controller: \"IndexController:PrivatePage\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectToLoginIfNotAuthenticated\", priority: 41} Where: IndexController:privatePage - route name url - url or the route, url can contain parameters: \"/some-page/:param1\" methods - list of HTTP methods allowed for this route controller - controller to process request matched to this route. IndexController is the service alias in DI container and PrivatePage is the name of method to be called to process request. event_listeners - list of request-level event listeners for this route, for more information see \"Events and listeners\" section. Whole routing block can look like: routing: routes: IndexController:index: url: \"/\" methods: [\"GET\"] controller: \"IndexController:Index\" IndexController:loginPage: url: \"/login\" methods: [\"GET\"] controller: \"IndexController:LoginPage\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectIfAuthenticated\", priority: 41} event_listeners: - {event: kernelEvent.RequestReceived, listener: \"RequestLoggerSetter:CreateLogger\", priority: 15} - {event: kernelEvent.RequestTermination, listener: \"RequestLoggerSetter:CloseLogger\", priority: 100} We can see here two routes IndexController:index and IndexController:loginPage . Routes have two common event listeners ( RequestLoggerSetter:CreateLogger , RequestLoggerSetter:CloseLogger ), this listeners will run at every request. Also IndexController:loginPage has AuthService:RedirectIfAuthenticated listener, this listener will run only during GET /login request.","title":"routing"},{"location":"v0.4/2_configuration/#event_listeners","text":"This block describes application level event listeners. Can look like: event_listeners: - {event: kernelEvent.ApplicationLaunched, listener: \"SessionsMiddleware:InitRedisConnection\", priority: 10} - {event: kernelEvent.ApplicationTermination, listener: \"SessionsMiddleware:CloseRedisConnection\", priority: 10} For more information see \"Events and listeners\" section.","title":"event_listeners"},{"location":"v0.4/2_configuration/#parameters","text":"This block is simple key-value storage for some application parameters that can change in different environments or run cases. For example, you need some timeout value for some process and you want this timeout be 30 sec on prod server and 60 sec on dev server. You need to pass this value to corresponding service (in services configuration block). In such case you can define timeout_value parameter, use it by name as service-factory parameter in services section and it's will be stored in parameters section. So for different servers you should only change parameters section of config file. Example part of config file for prod server: services: SomeService: arguments: [\"#timeout_value\"] parameters: timeout_value: 30 Example part of config file for dev server: services: SomeService: arguments: [\"#timeout_value\"] parameters: timeout_value: 60","title":"parameters"},{"location":"v0.4/3_services_and_di_container/","text":"Gkernel uses bassbeaver/gioc as DI container. DI container is used to create entities during application run. Let's call that entities as Service . To create some Service you have to know what dependencies that service has, and how to build that new Service. \"Dependency\" - is some object (scalar value, pointer to other service etc.) that is required for Service to operate. \"How to build\" - is set of operations needed to create and configure Service. It's good approach to encapsulate knowledge \"how to build\" in object called Factory (for more information see Factory pattern ). Factory With bassbeaver/gioc Factory can be one of: Function. This function must return only one parameter and this parameter must be a pointer to new Service instance. Factory struct from bassbeaver/gioc package. Factory struct has next definition: type Factory struct { Arguments []string Create interface{} } Where : Create must be a function which knows how to create service (requirements to this function are same as for function from p.1). Arguments is an array of definitions for Create function arguments. N-th element of Arguments array is for N-th argument of Create function. But with Gkernel Container usage is simplified - Gkernel provides method: func (k *Kernel) RegisterService(alias string, factoryMethod interface{}, enableCaching bool) error Where: alias - Service alias (must correspond to Service alias from Config's services block) factoryMethod - function, which knows how to create Service. enableCaching - flag signaling the Container if container have to create this Service once and save pointer to it in cache, and for next requests for this Service just get it from cache, or Container have to honestly create new instance of service for each request. factoryMethod can have arguments, required for Service building. Gkernel reads description of that arguments from Config file from arguments key of Service definition. Each argument definition is a string and is interpreted in next ways: If first symbol of this string is @ - this definition is interpreted as service alias, so Container will try to find service with that alias. If first symbol of this string is # - this definition is interpreted as parameter name, so Container will try to find value of that parameter in Container's parameters bag. In other cases definition string is interpreted as value for corresponding argument of Create function. Container tries to cast value of each argument to required type, if cast failed - Container panics. For this moment Gkernel can not perform Service registration by himself (because it has paws ) and you have to call RegisterService manually, during application startup. Container usage. Service registration and service obtainment Simple example of Container usage. At first let's describe Services in Config file: ... services: UserProvider: arguments: [] AuthService: arguments: [\"@UserProvider\", \"/login\", \"/\"] Next, let's write Service and Service Factory code: import ( \"fmt\" \"github.com/bassbeaver/gkernel\" \"gkernel-skeleton/service/auth\" ) const ( UserProviderMiddlewareServiceAlias = \"UserProvider\" AuthServiceAlias = \"AuthService\" ) type UserProvider struct { // UserProvider knows how to get users data from storage, but we will omit that functionality here } func newUserProvider() *UserProvider { return &UserProvider{} } func RegisterUserProvider(kernelObj *gkernel.Kernel) { err := kernelObj.RegisterService(UserProviderMiddlewareServiceAlias, newUserProvider, true) if nil != err { panic(fmt.Sprintf(\"failed to register %s service, error: %s\", UserProviderMiddlewareServiceAlias, err.Error())) } } type AuthService struct { userProvider *UserProvider loginPageUrl string fallbackUrl string } func newAuthService(userLoader *UserProvider, loginPageUrl, fallbackUrl string) *AuthService { return &Service{ userProvider: userLoader, loginPageUrl: loginPageUrl, fallbackUrl: fallbackUrl, } } func RegisterAuthService(kernelObj *gkernel.Kernel) { err := kernelObj.RegisterService(AuthServiceAlias, newAuthService, true) if nil != err { panic(fmt.Sprintf(\"failed to register %s service, error: %s\", AuthServiceAlias, err.Error())) } } Finally, lets register Services in Container: kernelObj, kernelError := gkernel.NewKernel(\"/path/to/config\") if nil != kernelError { panic(kernelError) } RegisterAuthService(kernelObj) RegisterUserProvider(kernelObj) After that, Container can create Services (on demand) and inside of created AuthService already created UserProvider will be available. You can ask me \"and what about Service obtainment?\" . In real application most part of time you will be working with Controllers and Event Listeners and both of them should be registered in Container as Services (if you want have good application architecture) and in that case you do not need explicit Service obtainment, Gkernel and Container will do it for you. But, if for some reason you really want to get some Service explicitly, you can use: kernelObj.GetContainer().GetByAlias(\"service_alias\") Note: in our example we called RegisterAuthService before RegisterUserProvider and you can ask: \"Why before? AuthService is dependent from UserProvider, that code will fail.\" . Answer is: you can register services in any order because no services are created during registration process. Services are created by Container only when they are really needed. For more examples you can see Gkernel skeleton application .","title":"Services and DI container"},{"location":"v0.4/3_services_and_di_container/#factory","text":"With bassbeaver/gioc Factory can be one of: Function. This function must return only one parameter and this parameter must be a pointer to new Service instance. Factory struct from bassbeaver/gioc package. Factory struct has next definition: type Factory struct { Arguments []string Create interface{} } Where : Create must be a function which knows how to create service (requirements to this function are same as for function from p.1). Arguments is an array of definitions for Create function arguments. N-th element of Arguments array is for N-th argument of Create function. But with Gkernel Container usage is simplified - Gkernel provides method: func (k *Kernel) RegisterService(alias string, factoryMethod interface{}, enableCaching bool) error Where: alias - Service alias (must correspond to Service alias from Config's services block) factoryMethod - function, which knows how to create Service. enableCaching - flag signaling the Container if container have to create this Service once and save pointer to it in cache, and for next requests for this Service just get it from cache, or Container have to honestly create new instance of service for each request. factoryMethod can have arguments, required for Service building. Gkernel reads description of that arguments from Config file from arguments key of Service definition. Each argument definition is a string and is interpreted in next ways: If first symbol of this string is @ - this definition is interpreted as service alias, so Container will try to find service with that alias. If first symbol of this string is # - this definition is interpreted as parameter name, so Container will try to find value of that parameter in Container's parameters bag. In other cases definition string is interpreted as value for corresponding argument of Create function. Container tries to cast value of each argument to required type, if cast failed - Container panics. For this moment Gkernel can not perform Service registration by himself (because it has paws ) and you have to call RegisterService manually, during application startup.","title":"Factory"},{"location":"v0.4/3_services_and_di_container/#container-usage-service-registration-and-service-obtainment","text":"Simple example of Container usage. At first let's describe Services in Config file: ... services: UserProvider: arguments: [] AuthService: arguments: [\"@UserProvider\", \"/login\", \"/\"] Next, let's write Service and Service Factory code: import ( \"fmt\" \"github.com/bassbeaver/gkernel\" \"gkernel-skeleton/service/auth\" ) const ( UserProviderMiddlewareServiceAlias = \"UserProvider\" AuthServiceAlias = \"AuthService\" ) type UserProvider struct { // UserProvider knows how to get users data from storage, but we will omit that functionality here } func newUserProvider() *UserProvider { return &UserProvider{} } func RegisterUserProvider(kernelObj *gkernel.Kernel) { err := kernelObj.RegisterService(UserProviderMiddlewareServiceAlias, newUserProvider, true) if nil != err { panic(fmt.Sprintf(\"failed to register %s service, error: %s\", UserProviderMiddlewareServiceAlias, err.Error())) } } type AuthService struct { userProvider *UserProvider loginPageUrl string fallbackUrl string } func newAuthService(userLoader *UserProvider, loginPageUrl, fallbackUrl string) *AuthService { return &Service{ userProvider: userLoader, loginPageUrl: loginPageUrl, fallbackUrl: fallbackUrl, } } func RegisterAuthService(kernelObj *gkernel.Kernel) { err := kernelObj.RegisterService(AuthServiceAlias, newAuthService, true) if nil != err { panic(fmt.Sprintf(\"failed to register %s service, error: %s\", AuthServiceAlias, err.Error())) } } Finally, lets register Services in Container: kernelObj, kernelError := gkernel.NewKernel(\"/path/to/config\") if nil != kernelError { panic(kernelError) } RegisterAuthService(kernelObj) RegisterUserProvider(kernelObj) After that, Container can create Services (on demand) and inside of created AuthService already created UserProvider will be available. You can ask me \"and what about Service obtainment?\" . In real application most part of time you will be working with Controllers and Event Listeners and both of them should be registered in Container as Services (if you want have good application architecture) and in that case you do not need explicit Service obtainment, Gkernel and Container will do it for you. But, if for some reason you really want to get some Service explicitly, you can use: kernelObj.GetContainer().GetByAlias(\"service_alias\") Note: in our example we called RegisterAuthService before RegisterUserProvider and you can ask: \"Why before? AuthService is dependent from UserProvider, that code will fail.\" . Answer is: you can register services in any order because no services are created during registration process. Services are created by Container only when they are really needed. For more examples you can see Gkernel skeleton application .","title":"Container usage. Service registration and service obtainment"},{"location":"v0.4/4_request_and_response/","text":"HTTP web applications work in request-response mode and Gkernel uses certain objects to represent and work with that requests and responses. Request Gkernel uses standard net/http Request type to represent HTTP request received by a server. Response Response represents result of request processing that should be sent to user. Response can be of any type that implements next interface: type Response interface { GetHttpStatus() int GetHeaders() http.Header GetBodyBytes() *bytes.Buffer } Gkernel framework provides bunch of ready to use Response types: BytesResponse Represents simples response - slices of bytes. BytesResponse has next fields: Body *bytes.Buffer - stores response bytes, that should be sent to user. BytesResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - intended to simplify adding new headers to response. You can call r.GetHeaders().Set(\"MyHeader\", \"my header value\") or just r.HeaderSet(\"MyHeader\", \"my header value\") func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) ClearBody() - removes old Body bytes buffer, creates new and empty func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer To create new BytesResponse you can use factory method NewBytesResponse() : import ( \"github.com/bassbeaver/gkernel/response\" ) responseObj := response.NewBytesResponse() BytesResponseWriter Is a simple wrapper around BytesResponse to use in case when you need to use Gkernel's BytesResponse as http.ResponseWriter . For example, adding pprof endpoints to Gkernel's routing: package main import ( \"github.com/bassbeaver/gkernel\" kernelResponse \"github.com/bassbeaver/gkernel/response\" \"net/http\" \"net/http/pprof\" ) ... kernelObj, kernelError := gkernel.NewKernel(\"/path/to/config\") if nil != kernelError { panic(kernelError) } ... registerPprofRoute := func(name, url string, handlerFunc http.HandlerFunc) { kernelObj.RegisterRoute(&gkernel.Route{ Name: name, Url: url, Methods: []string{http.MethodGet}, Controller: func(request *http.Request) kernelResponse.Response { w := kernelResponse.NewBytesResponseWriter() handlerFunc(w, request) return w }, }) } registerPprofRoute(\"pprof:index\", \"/debug/pprof/\", pprof.Index) registerPprofRoute(\"pprof:cmdline\", \"/debug/pprof/cmdline\", pprof.Cmdline) registerPprofRoute(\"pprof:profile\", \"/debug/pprof/profile\", pprof.Profile) registerPprofRoute(\"pprof:symbol\", \"/debug/pprof/profile\", pprof.Symbol) registerPprofRoute(\"pprof:trace\", \"/debug/pprof/trace\", pprof.Trace) registerPprofRoute(\"pprof:heap\", \"/debug/pprof/heap\", pprof.Index) RedirectResponse Represents response that should be sent to useragent to perform redirect. To create new BytesResponse you can use factory method: NewRedirectResponse(request *http.Request, url string, httpStatus int) *RedirectResponse Where: request is current Request object url - URL to redirect to httpStatus HTTP status to set for this response. As default status you can use http.StatusSeeOther (303) status. ViewResponse You can use ViewResponse when you need to return rendered template (usually html template). ViewResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - sets request's header value func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer func (r *ViewResponse) SetData(data interface{}) - sets template's data (variables used for templates rendering) func (r *ViewResponse) SetTemplate(tpl *template.Template) - is used with Gkernel and usually you do not need this method. In most cases, to return rendered template (view) as a Response you will be enough to use factory method: NewViewResponse(templateName string) *ViewResponse Example (from bassbeaver/gkernel-skeleton IndexController ): func (c *IndexController) PageWithParam(request *http.Request) kernelResponse.Response { var viewData struct { CsrfToken string User auth.UserInterface Header struct { Title string } H1 string Param string } viewData.Header.Title = \"gkernel skeleton site\" viewData.H1 = \"This is page with URL parameter\" viewData.CsrfToken = csrfService.GetTokenFromRequestContext(request) if auth.GetUser(request) != nil { viewData.User = auth.GetUser(request).(*user_provider.UserStub) } viewData.Param = request.URL.Query().Get(\":parameterValue\") response := kernelResponse.NewViewResponse(\"index/page-with-param.gohtml\") response.SetData(viewData) return response } Notice: templateName from NewViewResponse(templateName string) *ViewResponse is relative path to template file. Full path to template file Gkernel determines according to the following algorithm: <path to application Config file>/<templates_path>/<templateName> Where: <path to application Config file> - path to application's configuration file <templates_path> - value application's configuration file <templateName> - template's name from NewViewResponse(templateName string) factory method Access to Gkernels html/template object and registration of custom template functions To work with templates Gkernel uses html/template library. Templates parsing happens during templates during application startup after Gkernel's Run() method call. Sometimes you need access to template.Template object (to register custom template functions or make other configuration). Gkernel provides appropriate method GetTemplates() . Example of custom template functions registration: kernelObj, kernelError := gkernel.NewKernel(\"/path/to/config\") ... kernelObj.GetTemplates().Funcs(template.FuncMap{ \"sequence\": func(size int) []int { sequence := make([]int, size) for i := 0; i < size; i++ { sequence[i] = i } return sequence }, \"addInt\": func(a, b int) int { return a + b }, \"subInt\": func(a, b int) int { return a - b }, }) After that you can use these functions in templates: {{range $i := sequence $pagination.TotalPages}} {{$pageNum := addInt $i 1}} <a href=\"{{$pagination.CurrentUrl}}?page={{$pageNum}}\">{{$pageNum}}</a> {{end}} JsonResponse Represents json encoded response. JsonResponse has next fields: Body interface{} - response value, that should be json encoded and sent to user JsonResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - sets request's header value func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer To create new JsonResponse you can use factory method: NewJsonResponse() *JsonResponse this factory method sets Content-Type header to application/json for created Response object. Also, Gkernel provides factory method to create Json Api Response: NewJsonApiResponse() *JsonResponse It is similar to NewJsonResponse() except that sets Content-Type header to application/json . WebsocketUpgradeResponse Represents Response used to upgrade protocol to WebSocket. To create new WebsocketUpgradeResponse you can use factory method NewWebsocketUpgradeResponse(upgrader *websocket.Upgrader, controller WebSocketController) *WebsocketUpgradeResponse Where: upgrader - instance of gorilla/websocket.Upgrader controller - function with signature: func(*websocket.Conn)","title":"Request and Response"},{"location":"v0.4/4_request_and_response/#request","text":"Gkernel uses standard net/http Request type to represent HTTP request received by a server.","title":"Request"},{"location":"v0.4/4_request_and_response/#response","text":"Response represents result of request processing that should be sent to user. Response can be of any type that implements next interface: type Response interface { GetHttpStatus() int GetHeaders() http.Header GetBodyBytes() *bytes.Buffer } Gkernel framework provides bunch of ready to use Response types:","title":"Response"},{"location":"v0.4/4_request_and_response/#bytesresponse","text":"Represents simples response - slices of bytes. BytesResponse has next fields: Body *bytes.Buffer - stores response bytes, that should be sent to user. BytesResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - intended to simplify adding new headers to response. You can call r.GetHeaders().Set(\"MyHeader\", \"my header value\") or just r.HeaderSet(\"MyHeader\", \"my header value\") func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) ClearBody() - removes old Body bytes buffer, creates new and empty func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer To create new BytesResponse you can use factory method NewBytesResponse() : import ( \"github.com/bassbeaver/gkernel/response\" ) responseObj := response.NewBytesResponse()","title":"BytesResponse"},{"location":"v0.4/4_request_and_response/#bytesresponsewriter","text":"Is a simple wrapper around BytesResponse to use in case when you need to use Gkernel's BytesResponse as http.ResponseWriter . For example, adding pprof endpoints to Gkernel's routing: package main import ( \"github.com/bassbeaver/gkernel\" kernelResponse \"github.com/bassbeaver/gkernel/response\" \"net/http\" \"net/http/pprof\" ) ... kernelObj, kernelError := gkernel.NewKernel(\"/path/to/config\") if nil != kernelError { panic(kernelError) } ... registerPprofRoute := func(name, url string, handlerFunc http.HandlerFunc) { kernelObj.RegisterRoute(&gkernel.Route{ Name: name, Url: url, Methods: []string{http.MethodGet}, Controller: func(request *http.Request) kernelResponse.Response { w := kernelResponse.NewBytesResponseWriter() handlerFunc(w, request) return w }, }) } registerPprofRoute(\"pprof:index\", \"/debug/pprof/\", pprof.Index) registerPprofRoute(\"pprof:cmdline\", \"/debug/pprof/cmdline\", pprof.Cmdline) registerPprofRoute(\"pprof:profile\", \"/debug/pprof/profile\", pprof.Profile) registerPprofRoute(\"pprof:symbol\", \"/debug/pprof/profile\", pprof.Symbol) registerPprofRoute(\"pprof:trace\", \"/debug/pprof/trace\", pprof.Trace) registerPprofRoute(\"pprof:heap\", \"/debug/pprof/heap\", pprof.Index)","title":"BytesResponseWriter"},{"location":"v0.4/4_request_and_response/#redirectresponse","text":"Represents response that should be sent to useragent to perform redirect. To create new BytesResponse you can use factory method: NewRedirectResponse(request *http.Request, url string, httpStatus int) *RedirectResponse Where: request is current Request object url - URL to redirect to httpStatus HTTP status to set for this response. As default status you can use http.StatusSeeOther (303) status.","title":"RedirectResponse"},{"location":"v0.4/4_request_and_response/#viewresponse","text":"You can use ViewResponse when you need to return rendered template (usually html template). ViewResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - sets request's header value func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer func (r *ViewResponse) SetData(data interface{}) - sets template's data (variables used for templates rendering) func (r *ViewResponse) SetTemplate(tpl *template.Template) - is used with Gkernel and usually you do not need this method. In most cases, to return rendered template (view) as a Response you will be enough to use factory method: NewViewResponse(templateName string) *ViewResponse Example (from bassbeaver/gkernel-skeleton IndexController ): func (c *IndexController) PageWithParam(request *http.Request) kernelResponse.Response { var viewData struct { CsrfToken string User auth.UserInterface Header struct { Title string } H1 string Param string } viewData.Header.Title = \"gkernel skeleton site\" viewData.H1 = \"This is page with URL parameter\" viewData.CsrfToken = csrfService.GetTokenFromRequestContext(request) if auth.GetUser(request) != nil { viewData.User = auth.GetUser(request).(*user_provider.UserStub) } viewData.Param = request.URL.Query().Get(\":parameterValue\") response := kernelResponse.NewViewResponse(\"index/page-with-param.gohtml\") response.SetData(viewData) return response } Notice: templateName from NewViewResponse(templateName string) *ViewResponse is relative path to template file. Full path to template file Gkernel determines according to the following algorithm: <path to application Config file>/<templates_path>/<templateName> Where: <path to application Config file> - path to application's configuration file <templates_path> - value application's configuration file <templateName> - template's name from NewViewResponse(templateName string) factory method","title":"ViewResponse"},{"location":"v0.4/4_request_and_response/#access-to-gkernels-htmltemplate-object-and-registration-of-custom-template-functions","text":"To work with templates Gkernel uses html/template library. Templates parsing happens during templates during application startup after Gkernel's Run() method call. Sometimes you need access to template.Template object (to register custom template functions or make other configuration). Gkernel provides appropriate method GetTemplates() . Example of custom template functions registration: kernelObj, kernelError := gkernel.NewKernel(\"/path/to/config\") ... kernelObj.GetTemplates().Funcs(template.FuncMap{ \"sequence\": func(size int) []int { sequence := make([]int, size) for i := 0; i < size; i++ { sequence[i] = i } return sequence }, \"addInt\": func(a, b int) int { return a + b }, \"subInt\": func(a, b int) int { return a - b }, }) After that you can use these functions in templates: {{range $i := sequence $pagination.TotalPages}} {{$pageNum := addInt $i 1}} <a href=\"{{$pagination.CurrentUrl}}?page={{$pageNum}}\">{{$pageNum}}</a> {{end}}","title":"Access to Gkernels html/template object and registration of custom template functions"},{"location":"v0.4/4_request_and_response/#jsonresponse","text":"Represents json encoded response. JsonResponse has next fields: Body interface{} - response value, that should be json encoded and sent to user JsonResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - sets request's header value func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer To create new JsonResponse you can use factory method: NewJsonResponse() *JsonResponse this factory method sets Content-Type header to application/json for created Response object. Also, Gkernel provides factory method to create Json Api Response: NewJsonApiResponse() *JsonResponse It is similar to NewJsonResponse() except that sets Content-Type header to application/json .","title":"JsonResponse"},{"location":"v0.4/4_request_and_response/#websocketupgraderesponse","text":"Represents Response used to upgrade protocol to WebSocket. To create new WebsocketUpgradeResponse you can use factory method NewWebsocketUpgradeResponse(upgrader *websocket.Upgrader, controller WebSocketController) *WebsocketUpgradeResponse Where: upgrader - instance of gorilla/websocket.Upgrader controller - function with signature: func(*websocket.Conn)","title":"WebsocketUpgradeResponse"},{"location":"v0.4/5_routing_and_controllers/","text":"Routing Route determines connection between URL and Controller, designed to process requests to that URL. To represent Route in code, Gkernel provides Route type. Route has next fields: Name, string - name of the route Methods, []string - array of HTTP method names. Route will only process requests made using that methods. Url, string Controller, Controller - Controller to process request Main way to create routes in Gkernel application is to describe routes in Configuration file. This way is described in Configuration section of this documentation. But also, you can register routes within the code. Gkernel provides appropriate method for this: func (k *Kernel) RegisterRoute(route *Route) *Kernel Route URL parameters Sometimes you will need to capture segments of the URI within your route. To achieve this you have to declare rote with parameter in URL. Configuration file example for this case: IndexController:pageWithParam: url: \"/page-with-param/:parameterValue\" methods: [\"GET\"] controller: \"IndexController:PageWithParam\" Where declared parameter is :parameterValue . Captured parameters live in Request object. To obtain captured parameter inside controller you have to: import ( kernelResponse \"github.com/bassbeaver/gkernel/response\" \"net/http\" ) func (c *IndexController) PageWithParam(request *http.Request) kernelResponse.Response { ... urlParam := request.URL.Query().Get(\":parameterValue\") ... } Controller Basically Controller is function that receive request object and have to return response object. Controller function should have next signature: import ( kernelResponse \"github.com/bassbeaver/gkernel/response\" \"net/http\" ) func(*http.Request) kernelResponse.Response Gkernel's approach to Controllers is to register Service where some methods have appropriate (Controller's) signature.","title":"Routing and Controllers"},{"location":"v0.4/5_routing_and_controllers/#routing","text":"Route determines connection between URL and Controller, designed to process requests to that URL. To represent Route in code, Gkernel provides Route type. Route has next fields: Name, string - name of the route Methods, []string - array of HTTP method names. Route will only process requests made using that methods. Url, string Controller, Controller - Controller to process request Main way to create routes in Gkernel application is to describe routes in Configuration file. This way is described in Configuration section of this documentation. But also, you can register routes within the code. Gkernel provides appropriate method for this: func (k *Kernel) RegisterRoute(route *Route) *Kernel","title":"Routing"},{"location":"v0.4/5_routing_and_controllers/#route-url-parameters","text":"Sometimes you will need to capture segments of the URI within your route. To achieve this you have to declare rote with parameter in URL. Configuration file example for this case: IndexController:pageWithParam: url: \"/page-with-param/:parameterValue\" methods: [\"GET\"] controller: \"IndexController:PageWithParam\" Where declared parameter is :parameterValue . Captured parameters live in Request object. To obtain captured parameter inside controller you have to: import ( kernelResponse \"github.com/bassbeaver/gkernel/response\" \"net/http\" ) func (c *IndexController) PageWithParam(request *http.Request) kernelResponse.Response { ... urlParam := request.URL.Query().Get(\":parameterValue\") ... }","title":"Route URL parameters"},{"location":"v0.4/5_routing_and_controllers/#controller","text":"Basically Controller is function that receive request object and have to return response object. Controller function should have next signature: import ( kernelResponse \"github.com/bassbeaver/gkernel/response\" \"net/http\" ) func(*http.Request) kernelResponse.Response Gkernel's approach to Controllers is to register Service where some methods have appropriate (Controller's) signature.","title":"Controller"},{"location":"v0.4/6_events_and_listeners/","text":"Gkernel is event-based framework, so Event and Listener are very important concepts in Gkernel's architecture. Event is an object that represents some happening inside application during it's operation. Every event have to implement interface: type Event interface { StopPropagation() IsPropagationStopped() bool } To process Event Listener object is used. Listener is just a function with one argument, and type of that argument have to correspond to Event's type. There can be multiple listeners for one event, this is called Listeners Chain and Event is propagating through that chain. Order of Listeners in chain is determined by Listeners priority (the lower the priority first). Event's propagation inside the Listeners Chain can be stopped by calling StopPropagation() method of the Event object. Main way to register Listened is to declare it in Configuration file: IndexController:privatePage: url: \"/private-page\" methods: [\"GET\"] controller: \"IndexController:PrivatePage\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectToLoginIfNotAuthenticated\", priority: 41} This example shows registration of Listener for RequestReceived Event, with priority 41 and where Listener is method RedirectToLoginIfNotAuthenticated from AuthService Service. Event types Gkernel's events can be application level and request level . Application level events Application level events are used to manage request-processing flow. There are next application level events: ApplicationLaunched Is being dispatched after application started, and configured but before it started to listen it's port. Can be used to establish DB connection, cache warming, etc. ApplicationTermination Is being dispatched during application shut down process. Can be used to close DB connections, exporting of some cached data, etc. Application level events has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetContainer() *gioc.Container - returns DI Container object used by Application. Application level events has next attributes: Errors *[]error - slice of errors occurred during application shutdown process Request level events There are next request level events: RequestReceived Is being dispatched after request was received by framework but before it was passed to controller. Can be used to read user's session from the storage, for authentification & authorization, etc. RequestReceived Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially RequestReceived Event has no Response (method returns nil ) SetResponse(responseObj response.Response) - stops Event's propagation and sends provided Response to user. RequestProcessed Is being dispatched after Controller has processed Request. Contains Response object returned from Controller. RequestProcessed Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially this will be Response returned by Controller SetResponse(responseObj response.Response) - sets Response object. Notice: unlike RequestReceived.SetResponse() this method does not stop Event's propagation ResponseBeforeSend Is being dispatched after RequestProcessed Event was processed. Can modify Response but can not replace it with new object. ResponseBeforeSend Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object RequestTermination Is being dispatched after Response was sent to user. Can be used for logs exporting and others after-request activities. RequestTermination Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object GetResponse() response.Response - gets Response object RuntimeError In case of panic during Request processing Gkernel automatically recovers that panic, creates RuntimeError object to represent that panic and dispatches RuntimeError. RuntimeError Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially RuntimeError Event has no Response (method returns nil ) SetResponse(responseObj response.Response) - stops Event's propagation and sends provided Response to user. GetError() *kernelError.RuntimeError - returns RuntimeError object that represents recovered panic","title":"Events and Listeners"},{"location":"v0.4/6_events_and_listeners/#event-types","text":"Gkernel's events can be application level and request level .","title":"Event types"},{"location":"v0.4/6_events_and_listeners/#application-level-events","text":"Application level events are used to manage request-processing flow. There are next application level events:","title":"Application level events"},{"location":"v0.4/6_events_and_listeners/#applicationlaunched","text":"Is being dispatched after application started, and configured but before it started to listen it's port. Can be used to establish DB connection, cache warming, etc.","title":"ApplicationLaunched"},{"location":"v0.4/6_events_and_listeners/#applicationtermination","text":"Is being dispatched during application shut down process. Can be used to close DB connections, exporting of some cached data, etc. Application level events has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetContainer() *gioc.Container - returns DI Container object used by Application. Application level events has next attributes: Errors *[]error - slice of errors occurred during application shutdown process","title":"ApplicationTermination"},{"location":"v0.4/6_events_and_listeners/#request-level-events","text":"There are next request level events:","title":"Request level events"},{"location":"v0.4/6_events_and_listeners/#requestreceived","text":"Is being dispatched after request was received by framework but before it was passed to controller. Can be used to read user's session from the storage, for authentification & authorization, etc. RequestReceived Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially RequestReceived Event has no Response (method returns nil ) SetResponse(responseObj response.Response) - stops Event's propagation and sends provided Response to user.","title":"RequestReceived"},{"location":"v0.4/6_events_and_listeners/#requestprocessed","text":"Is being dispatched after Controller has processed Request. Contains Response object returned from Controller. RequestProcessed Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially this will be Response returned by Controller SetResponse(responseObj response.Response) - sets Response object. Notice: unlike RequestReceived.SetResponse() this method does not stop Event's propagation","title":"RequestProcessed"},{"location":"v0.4/6_events_and_listeners/#responsebeforesend","text":"Is being dispatched after RequestProcessed Event was processed. Can modify Response but can not replace it with new object. ResponseBeforeSend Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object","title":"ResponseBeforeSend"},{"location":"v0.4/6_events_and_listeners/#requesttermination","text":"Is being dispatched after Response was sent to user. Can be used for logs exporting and others after-request activities. RequestTermination Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object GetResponse() response.Response - gets Response object","title":"RequestTermination"},{"location":"v0.4/6_events_and_listeners/#runtimeerror","text":"In case of panic during Request processing Gkernel automatically recovers that panic, creates RuntimeError object to represent that panic and dispatches RuntimeError. RuntimeError Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially RuntimeError Event has no Response (method returns nil ) SetResponse(responseObj response.Response) - stops Event's propagation and sends provided Response to user. GetError() *kernelError.RuntimeError - returns RuntimeError object that represents recovered panic","title":"RuntimeError"},{"location":"v1/1_main-concepts/","text":"Basic entities Main idea of Gkernel framework is to organize request processing flow which is: controlled by events processed by services, and services are managed by Service Container Framework determines next main entities for request processing: Kernel - represents whole piece of framework logic that have to be run in some invocation environment (web, CLI) Controller - function that receive incoming signals (HTTP request object, CLI command) and have to return outcome signals (HTTP response object, CLI command processing error etc.). Event - some event that happened during application life, HTTP request processing, or CLI command processing. These events are dispatched by the framework. Event listener - function that receive and process events (dispatched by the framework) and can affect incoming signals processing flow. HTTP Request - represents an HTTP request received by a server. Gkernel uses standard net/http Request type. HTTP Response - represents result of request processing, that should be sent to user. CLI Command - represents CLI command to be executed. Kernel Gkernel framework have two kernel implementation - for web and for CLI environments. github.com/bassbeaver/gkernel/web package contains kernel and other entities for web environment. github.com/bassbeaver/gkernel/cli package contains kernel and other entities for CLI environment. Configuration Gkernel uses yaml files to describe application configuration. Path to folder, containing config files, should be passed to Kernel constructor. Config files describe application parameters (like port to listen on, environment etc.), routes, services and event listeners. Under the hood to work with config files Gkernel uses viper library. Viper can read json , toml , yaml , yml , properties , props , prop , hcl files, so, in fact, any of that file types can be used as configuration files for Gkernel, but we suggest to use yaml . While reading config path (directory) Gkernel reads any allowed (that Viper can read) file from that directory and treats it like configuration file. Therefore it is recommended to store config files in separate folder and not mix config files with other files to avoid erroneous read of non-config file. Services and DI container Service is a logical concept of some complete component or functionality block inside a program with a purpose that different clients can reuse it for different purposes. Mostly all parts of application can be referenced as services. Controller is a service, event listener is a service, DB connection is a service, etc. As one of it's main parts Gkernel framework has DI container. It used for managing dependencies of application components (services) and performing dependency injection. (If you are not familiar with Dependency injection concept, you can read this article ). bassbeaver/gioc library is used as DI container.","title":"Main concepts"},{"location":"v1/1_main-concepts/#basic-entities","text":"Main idea of Gkernel framework is to organize request processing flow which is: controlled by events processed by services, and services are managed by Service Container Framework determines next main entities for request processing: Kernel - represents whole piece of framework logic that have to be run in some invocation environment (web, CLI) Controller - function that receive incoming signals (HTTP request object, CLI command) and have to return outcome signals (HTTP response object, CLI command processing error etc.). Event - some event that happened during application life, HTTP request processing, or CLI command processing. These events are dispatched by the framework. Event listener - function that receive and process events (dispatched by the framework) and can affect incoming signals processing flow. HTTP Request - represents an HTTP request received by a server. Gkernel uses standard net/http Request type. HTTP Response - represents result of request processing, that should be sent to user. CLI Command - represents CLI command to be executed.","title":"Basic entities"},{"location":"v1/1_main-concepts/#kernel","text":"Gkernel framework have two kernel implementation - for web and for CLI environments. github.com/bassbeaver/gkernel/web package contains kernel and other entities for web environment. github.com/bassbeaver/gkernel/cli package contains kernel and other entities for CLI environment.","title":"Kernel"},{"location":"v1/1_main-concepts/#configuration","text":"Gkernel uses yaml files to describe application configuration. Path to folder, containing config files, should be passed to Kernel constructor. Config files describe application parameters (like port to listen on, environment etc.), routes, services and event listeners. Under the hood to work with config files Gkernel uses viper library. Viper can read json , toml , yaml , yml , properties , props , prop , hcl files, so, in fact, any of that file types can be used as configuration files for Gkernel, but we suggest to use yaml . While reading config path (directory) Gkernel reads any allowed (that Viper can read) file from that directory and treats it like configuration file. Therefore it is recommended to store config files in separate folder and not mix config files with other files to avoid erroneous read of non-config file.","title":"Configuration"},{"location":"v1/1_main-concepts/#services-and-di-container","text":"Service is a logical concept of some complete component or functionality block inside a program with a purpose that different clients can reuse it for different purposes. Mostly all parts of application can be referenced as services. Controller is a service, event listener is a service, DB connection is a service, etc. As one of it's main parts Gkernel framework has DI container. It used for managing dependencies of application components (services) and performing dependency injection. (If you are not familiar with Dependency injection concept, you can read this article ). bassbeaver/gioc library is used as DI container.","title":"Services and DI container"},{"location":"v1/2_configuration/","text":"Gkernel uses yaml files to describe application configuration. Path to folder containing this files should be passed to Kernel constructor. Config files describe application parameters (like port to listen on), web routes, CLI commands, services and event listeners. Simple example: import ( webKernel \"github.com/bassbeaver/gkernel/web\" ) ... var configPath string configPath = \"/path/to/config\" kernelObj, kernelError := webKernel.NewKernel(configPath) It's a good idea to get this path as program argument. This approach is used in gkernel skeleton application : import ( \"flag\" \"fmt\" webKernel \"github.com/bassbeaver/gkernel/web\" kernelResponse \"github.com/bassbeaver/gkernel/web/response\" \"net/http\" \"net/http/pprof\" \"os\" ) ... // --- Processing application's arguments and flags flags := flag.NewFlagSet(\"flags\", flag.PanicOnError) configPathFlag := flags.String(\"config\", \"\", \"Path to config file\") flagsErr := flags.Parse(os.Args[1:]) if nil != flagsErr { panic(flagsErr) } // --- Creating application Kernel var configPath string if \"\" == *configPathFlag { curBinDir, curBinDirError := os.Getwd() if curBinDirError != nil { fmt.Println(\"Failed to determine path to own binary file\") panic(curBinDirError) } configPath = curBinDir + \"/config\" } else { configPath = *configPathFlag } kernelObj, kernelError := webKernel.NewKernel(configPath) if nil != kernelError { panic(kernelError) } Code above searches for program argument config passed to application during its start, if no argument found it tries to find config directory in its working directory and panics if failed to locate config files path. For example, if you build you app binary to /etc/gkernel-app and put your config files to /configs/gkernel-app-config it could be like: /etc/gkernel-app -config /configs/gkernel-app-config Configuration file overview Configuration file has next root keys: services web cli event_listeners parameters services services block describes all services in the application. Reading this block Kernel learns what services should be registered in DI container. Each service should have alias and arguments. Example: services: SessionsMiddleware: arguments: [\"sid\", \"@RedisConnection\"] Where SessionsMiddleware are service alias and arguments: [\"sid\", \"@RedisConnection\"] indicates that SessionsMiddleware service factory requires two arguments and first argument is just simple string with value sid and second argument should be a pointer to the RedisConnection service (this RedisConnection service have also to be described in config file). I want to bring your attention to that config file only describes services and service-factories arguments, and you have to register that factories in your application code. For more information about services and DI container see \"Services and DI container\" section. web This block describes all configuration related to web part of application (and used by web Kernel). Web block has next keys: * http_port Determines on what port application would be listening for HTTP requests. * templates_path Web Kernel of Gkernel uses go html/template package as a template engine to render pages. This templates are parsed during Kernel startup and web.templates_path key determines where Kernel should search for your templates. * shutdown_timeout Graceful shutdown timeout for http server in milliseconds, if not set default value of 500 will be used. * routing Routing key describes routes provided by application. More detailed description will be further. web.routing This sub block describes web routes provided by application. A route is a map from a URL path to the program logic, designed to process requests to that URL (we call that logic - Controller). Routing block has next sub-blocks: * routes - list of available routes * event_listeners - request-level event listeners common for all routes Route description looks like: IndexController:privatePage: url: \"/private-page\" methods: [\"GET\"] controller: \"IndexController:PrivatePage\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectToLoginIfNotAuthenticated\", priority: 41} Where: IndexController:privatePage - route name url - url or the route, url can contain parameters: \"/some-page/:param1\" methods - list of HTTP methods allowed for this route controller - controller to process request matched to this route. IndexController is the service alias in DI container and PrivatePage is the method name of IndexController service to be called to process request. event_listeners - list of request-level event listeners for this route, for more information see \"Events and listeners\" section. Whole web block can look like: web: http_port: 8081 templates_path: \"web/templates\" shutdown_timeout: 5000 routing: routes: IndexController:index: url: \"/\" methods: [\"GET\"] controller: \"IndexController:Index\" IndexController:loginPage: url: \"/login\" methods: [\"GET\"] controller: \"IndexController:LoginPage\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectIfAuthenticated\", priority: 41} event_listeners: - {event: kernelEvent.RequestReceived, listener: \"RequestLoggerSetter:SetLoggerToRequestContext\", priority: 15} - {event: kernelEvent.RequestTermination, listener: \"RequestLoggerSetter:CloseLogger\", priority: 100} We can see here two routes IndexController:index and IndexController:loginPage . Routes have two common event listeners ( RequestLoggerSetter:SetLoggerToRequestContext , RequestLoggerSetter:CloseLogger ), these listeners will run at every request. Also IndexController:loginPage has AuthService:RedirectIfAuthenticated listener, this listener will run only during GET /login request. cli This block describes console commands provided by application. A command is a map from CLI arguments to the program logic, designed to process such CLI requests. CLI block has next sub-blocks: * commands - list of available commands Command description looks like: CliController:command1: name: command1 controller: \"CliController:Command1\" help: \"first cli command\" Where: CliController:command1 - command alias (not used by Gkernel) name - name of command. Gkernel search this name in CLI arguments passed to program controller - controller to process command. CliController is the service alias in DI container and Command1 is the method name of CliController service to be called to process command. help - string for full command description shown when running the command with the --help option. Also, help strings of all commands CLI Kernel returns by Kernel.GetHelp() or Kernel.FormatHelp() methods. Whole cli block can look like: cli: commands: CliController:command1: name: command1 controller: \"CliController:Command1\" help: \"first cli command\" event_listeners This block describes application level event listeners. Can look like: event_listeners: - {event: kernelEvent.ApplicationLaunched, listener: \"RedisConnectionMiddleware:InitRedisConnection\", priority: 10} - {event: kernelEvent.ApplicationTermination, listener: \"RedisConnectionMiddleware:CloseRedisConnection\", priority: 10} For more information see \"Events and listeners\" section. parameters This block is simple key-value storage for some application parameters that can change in different environments or run cases. For example, you need some timeout value for some process and you want this timeout be 30 sec on prod server and 60 sec on dev server. You need to pass this value to corresponding service (in services configuration block). In such case you can define timeout_value parameter, use it by name as service-factory parameter in services section and it's will be stored in parameters section. So for different servers you should only change parameters section of config file. Example part of config file for prod server: services: SomeService: arguments: [\"#timeout_value\"] parameters: timeout_value: 30 Example part of config file for dev server: services: SomeService: arguments: [\"#timeout_value\"] parameters: timeout_value: 60","title":"Configuration"},{"location":"v1/2_configuration/#configuration-file-overview","text":"Configuration file has next root keys: services web cli event_listeners parameters","title":"Configuration file overview"},{"location":"v1/2_configuration/#services","text":"services block describes all services in the application. Reading this block Kernel learns what services should be registered in DI container. Each service should have alias and arguments. Example: services: SessionsMiddleware: arguments: [\"sid\", \"@RedisConnection\"] Where SessionsMiddleware are service alias and arguments: [\"sid\", \"@RedisConnection\"] indicates that SessionsMiddleware service factory requires two arguments and first argument is just simple string with value sid and second argument should be a pointer to the RedisConnection service (this RedisConnection service have also to be described in config file). I want to bring your attention to that config file only describes services and service-factories arguments, and you have to register that factories in your application code. For more information about services and DI container see \"Services and DI container\" section.","title":"services"},{"location":"v1/2_configuration/#web","text":"This block describes all configuration related to web part of application (and used by web Kernel). Web block has next keys: * http_port Determines on what port application would be listening for HTTP requests. * templates_path Web Kernel of Gkernel uses go html/template package as a template engine to render pages. This templates are parsed during Kernel startup and web.templates_path key determines where Kernel should search for your templates. * shutdown_timeout Graceful shutdown timeout for http server in milliseconds, if not set default value of 500 will be used. * routing Routing key describes routes provided by application. More detailed description will be further.","title":"web"},{"location":"v1/2_configuration/#webrouting","text":"This sub block describes web routes provided by application. A route is a map from a URL path to the program logic, designed to process requests to that URL (we call that logic - Controller). Routing block has next sub-blocks: * routes - list of available routes * event_listeners - request-level event listeners common for all routes Route description looks like: IndexController:privatePage: url: \"/private-page\" methods: [\"GET\"] controller: \"IndexController:PrivatePage\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectToLoginIfNotAuthenticated\", priority: 41} Where: IndexController:privatePage - route name url - url or the route, url can contain parameters: \"/some-page/:param1\" methods - list of HTTP methods allowed for this route controller - controller to process request matched to this route. IndexController is the service alias in DI container and PrivatePage is the method name of IndexController service to be called to process request. event_listeners - list of request-level event listeners for this route, for more information see \"Events and listeners\" section. Whole web block can look like: web: http_port: 8081 templates_path: \"web/templates\" shutdown_timeout: 5000 routing: routes: IndexController:index: url: \"/\" methods: [\"GET\"] controller: \"IndexController:Index\" IndexController:loginPage: url: \"/login\" methods: [\"GET\"] controller: \"IndexController:LoginPage\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectIfAuthenticated\", priority: 41} event_listeners: - {event: kernelEvent.RequestReceived, listener: \"RequestLoggerSetter:SetLoggerToRequestContext\", priority: 15} - {event: kernelEvent.RequestTermination, listener: \"RequestLoggerSetter:CloseLogger\", priority: 100} We can see here two routes IndexController:index and IndexController:loginPage . Routes have two common event listeners ( RequestLoggerSetter:SetLoggerToRequestContext , RequestLoggerSetter:CloseLogger ), these listeners will run at every request. Also IndexController:loginPage has AuthService:RedirectIfAuthenticated listener, this listener will run only during GET /login request.","title":"web.routing"},{"location":"v1/2_configuration/#cli","text":"This block describes console commands provided by application. A command is a map from CLI arguments to the program logic, designed to process such CLI requests. CLI block has next sub-blocks: * commands - list of available commands Command description looks like: CliController:command1: name: command1 controller: \"CliController:Command1\" help: \"first cli command\" Where: CliController:command1 - command alias (not used by Gkernel) name - name of command. Gkernel search this name in CLI arguments passed to program controller - controller to process command. CliController is the service alias in DI container and Command1 is the method name of CliController service to be called to process command. help - string for full command description shown when running the command with the --help option. Also, help strings of all commands CLI Kernel returns by Kernel.GetHelp() or Kernel.FormatHelp() methods. Whole cli block can look like: cli: commands: CliController:command1: name: command1 controller: \"CliController:Command1\" help: \"first cli command\"","title":"cli"},{"location":"v1/2_configuration/#event_listeners","text":"This block describes application level event listeners. Can look like: event_listeners: - {event: kernelEvent.ApplicationLaunched, listener: \"RedisConnectionMiddleware:InitRedisConnection\", priority: 10} - {event: kernelEvent.ApplicationTermination, listener: \"RedisConnectionMiddleware:CloseRedisConnection\", priority: 10} For more information see \"Events and listeners\" section.","title":"event_listeners"},{"location":"v1/2_configuration/#parameters","text":"This block is simple key-value storage for some application parameters that can change in different environments or run cases. For example, you need some timeout value for some process and you want this timeout be 30 sec on prod server and 60 sec on dev server. You need to pass this value to corresponding service (in services configuration block). In such case you can define timeout_value parameter, use it by name as service-factory parameter in services section and it's will be stored in parameters section. So for different servers you should only change parameters section of config file. Example part of config file for prod server: services: SomeService: arguments: [\"#timeout_value\"] parameters: timeout_value: 30 Example part of config file for dev server: services: SomeService: arguments: [\"#timeout_value\"] parameters: timeout_value: 60","title":"parameters"},{"location":"v1/3_services_and_di_container/","text":"Gkernel uses bassbeaver/gioc as DI container. DI container is used to create entities during application run. Let's call that entities as Service . To create some Service you have to know what dependencies that service has, and how to build that new Service. \"Dependency\" - is some object (scalar value, pointer to other service etc.) that is required for Service to operate. \"How to build\" - is set of operations needed to create and configure Service. It's good approach to encapsulate knowledge \"how to build\" in object called Factory (for more information see Factory pattern ). Factory With bassbeaver/gioc Factory can be one of: Function. This function must return only one parameter and this parameter must be a pointer to new Service instance. Factory struct from bassbeaver/gioc package. Factory struct has next definition: type Factory struct { Arguments []string Create interface{} } Where : Create must be a function which knows how to create service (requirements to this function are same as for function from p.1). Arguments is an array of definitions for Create function arguments. N-th element of Arguments array is for N-th argument of Create function. But with Gkernel Container usage is simplified - Gkernel provides method: func (k *Kernel) RegisterService(alias string, factoryMethod interface{}, enableCaching bool) error Where: alias - Service alias (must correspond to Service alias from Config's services block) factoryMethod - function, which knows how to create Service. enableCaching - flag signaling the Container if container have to create this Service once and save pointer to it in cache, and for next requests for this Service just get it from cache, or Container have to honestly create new instance of service for each request. factoryMethod can have arguments, required for Service building. Gkernel reads description of that arguments from Config file from arguments key of Service definition. Each argument definition is a string and is interpreted in next ways: If first symbol of this string is @ - this definition is interpreted as service alias, so Container will try to find service with that alias. If first symbol of this string is # - this definition is interpreted as parameter name, so Container will try to find value of that parameter in Container's parameters bag. In other cases definition string is interpreted as value for corresponding argument of Create function. Container tries to cast value of each argument to required type, if cast failed - Container panics. For this moment Gkernel can not perform Service registration by himself (because it has paws ) and you have to call RegisterService manually, during application startup. Container usage. Service registration and service obtainment Simple example of Container usage. At first let's describe Services in Config file: ... services: UserProvider: arguments: [] AuthService: arguments: [\"@UserProvider\", \"/login\", \"/\"] Next, let's write Service and Service Factory code: import ( \"fmt\" webKernel \"github.com/bassbeaver/gkernel/web\" \"gkernel-skeleton/service/auth\" ) const ( UserProviderMiddlewareServiceAlias = \"UserProvider\" AuthServiceAlias = \"AuthService\" ) type UserProvider struct { // UserProvider knows how to get users data from storage, but we will omit that functionality here } func newUserProvider() *UserProvider { return &UserProvider{} } func RegisterUserProvider(kernelObj *webKernel.Kernel) { err := kernelObj.RegisterService(UserProviderMiddlewareServiceAlias, newUserProvider, true) if nil != err { panic(fmt.Sprintf(\"failed to register %s service, error: %s\", UserProviderMiddlewareServiceAlias, err.Error())) } } type AuthService struct { userProvider *UserProvider loginPageUrl string fallbackUrl string } func newAuthService(userLoader *UserProvider, loginPageUrl, fallbackUrl string) *AuthService { return &Service{ userProvider: userLoader, loginPageUrl: loginPageUrl, fallbackUrl: fallbackUrl, } } func RegisterAuthService(kernelObj *webKernel.Kernel) { err := kernelObj.RegisterService(AuthServiceAlias, newAuthService, true) if nil != err { panic(fmt.Sprintf(\"failed to register %s service, error: %s\", AuthServiceAlias, err.Error())) } } Finally, lets register Services in Container: kernelObj, kernelError := webKernel.NewKernel(\"/path/to/config\") if nil != kernelError { panic(kernelError) } RegisterAuthService(kernelObj) RegisterUserProvider(kernelObj) After that, Container can create Services (on demand) and inside created AuthService already created UserProvider will be available. You can ask me \"and what about Service obtainment?\" . In real application most part of time you will be working with Controllers and Event Listeners and both of them should be registered in Container as Services (if you want to have good application architecture) and in that case you do not need explicit Service obtainment, Gkernel and Container will do it for you. But, if for some reason you really want to get some Service explicitly, you can use: kernelObj.GetContainer().GetByAlias(\"service_alias\") Note: in our example we called RegisterAuthService before RegisterUserProvider and you can ask: \"Why before? AuthService is dependent from UserProvider, that code will fail.\" . Answer is: you can register services in any order because no services are created during registration process. Services are created by Container only when they are really needed. For more examples you can see Gkernel skeleton application .","title":"Services and DI container"},{"location":"v1/3_services_and_di_container/#factory","text":"With bassbeaver/gioc Factory can be one of: Function. This function must return only one parameter and this parameter must be a pointer to new Service instance. Factory struct from bassbeaver/gioc package. Factory struct has next definition: type Factory struct { Arguments []string Create interface{} } Where : Create must be a function which knows how to create service (requirements to this function are same as for function from p.1). Arguments is an array of definitions for Create function arguments. N-th element of Arguments array is for N-th argument of Create function. But with Gkernel Container usage is simplified - Gkernel provides method: func (k *Kernel) RegisterService(alias string, factoryMethod interface{}, enableCaching bool) error Where: alias - Service alias (must correspond to Service alias from Config's services block) factoryMethod - function, which knows how to create Service. enableCaching - flag signaling the Container if container have to create this Service once and save pointer to it in cache, and for next requests for this Service just get it from cache, or Container have to honestly create new instance of service for each request. factoryMethod can have arguments, required for Service building. Gkernel reads description of that arguments from Config file from arguments key of Service definition. Each argument definition is a string and is interpreted in next ways: If first symbol of this string is @ - this definition is interpreted as service alias, so Container will try to find service with that alias. If first symbol of this string is # - this definition is interpreted as parameter name, so Container will try to find value of that parameter in Container's parameters bag. In other cases definition string is interpreted as value for corresponding argument of Create function. Container tries to cast value of each argument to required type, if cast failed - Container panics. For this moment Gkernel can not perform Service registration by himself (because it has paws ) and you have to call RegisterService manually, during application startup.","title":"Factory"},{"location":"v1/3_services_and_di_container/#container-usage-service-registration-and-service-obtainment","text":"Simple example of Container usage. At first let's describe Services in Config file: ... services: UserProvider: arguments: [] AuthService: arguments: [\"@UserProvider\", \"/login\", \"/\"] Next, let's write Service and Service Factory code: import ( \"fmt\" webKernel \"github.com/bassbeaver/gkernel/web\" \"gkernel-skeleton/service/auth\" ) const ( UserProviderMiddlewareServiceAlias = \"UserProvider\" AuthServiceAlias = \"AuthService\" ) type UserProvider struct { // UserProvider knows how to get users data from storage, but we will omit that functionality here } func newUserProvider() *UserProvider { return &UserProvider{} } func RegisterUserProvider(kernelObj *webKernel.Kernel) { err := kernelObj.RegisterService(UserProviderMiddlewareServiceAlias, newUserProvider, true) if nil != err { panic(fmt.Sprintf(\"failed to register %s service, error: %s\", UserProviderMiddlewareServiceAlias, err.Error())) } } type AuthService struct { userProvider *UserProvider loginPageUrl string fallbackUrl string } func newAuthService(userLoader *UserProvider, loginPageUrl, fallbackUrl string) *AuthService { return &Service{ userProvider: userLoader, loginPageUrl: loginPageUrl, fallbackUrl: fallbackUrl, } } func RegisterAuthService(kernelObj *webKernel.Kernel) { err := kernelObj.RegisterService(AuthServiceAlias, newAuthService, true) if nil != err { panic(fmt.Sprintf(\"failed to register %s service, error: %s\", AuthServiceAlias, err.Error())) } } Finally, lets register Services in Container: kernelObj, kernelError := webKernel.NewKernel(\"/path/to/config\") if nil != kernelError { panic(kernelError) } RegisterAuthService(kernelObj) RegisterUserProvider(kernelObj) After that, Container can create Services (on demand) and inside created AuthService already created UserProvider will be available. You can ask me \"and what about Service obtainment?\" . In real application most part of time you will be working with Controllers and Event Listeners and both of them should be registered in Container as Services (if you want to have good application architecture) and in that case you do not need explicit Service obtainment, Gkernel and Container will do it for you. But, if for some reason you really want to get some Service explicitly, you can use: kernelObj.GetContainer().GetByAlias(\"service_alias\") Note: in our example we called RegisterAuthService before RegisterUserProvider and you can ask: \"Why before? AuthService is dependent from UserProvider, that code will fail.\" . Answer is: you can register services in any order because no services are created during registration process. Services are created by Container only when they are really needed. For more examples you can see Gkernel skeleton application .","title":"Container usage. Service registration and service obtainment"},{"location":"v1/4_events_and_listeners/","text":"Gkernel is event-based framework, so Event and Listener are very important concepts in Gkernel's architecture. Event is an object that represents some happening inside application during it's operation. Every event have to implement interface: type Event interface { StopPropagation() IsPropagationStopped() bool } To process Event Listener object is used. Listener itself is method with one argument, and type of that argument have to correspond to Event's type. Generally, Event Listener object have to be a Service with method of Listener type. There can be multiple listeners for one event, this is called Listeners Chain and Event is propagating through that chain. Order of Listeners in chain is determined by Listeners priority (the lower the priority first). Event's propagation inside the Listeners Chain can be stopped by calling StopPropagation() method of the Event object. Main way to register Listened is to declare it in Configuration file: IndexController:privatePage: url: \"/private-page\" methods: [\"GET\"] controller: \"IndexController:PrivatePage\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectToLoginIfNotAuthenticated\", priority: 41} This example shows registration of Listener for RequestReceived Event, with priority 41 and where Listener is method RedirectToLoginIfNotAuthenticated from AuthService Service. Event types Gkernel's events can be application level and request level (web request or CLI command). Application level events Application level events are used to manage request-processing flow. There are next application level events: ApplicationLaunched Is being dispatched after application started, and configured but before it started to listen it's port. Can be used to establish DB connection, cache warming, etc. ApplicationTermination Is being dispatched during application shut down process. Can be used to close DB connections, exporting of some cached data, etc. Application level events has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetContainer() *gioc.Container - returns DI Container object used by Application. Application level events has next attributes: Errors *[]error - slice of errors occurred during application shutdown process Request level events About request level events you can reed in corresponding sections: web and CLI .","title":"Events and Listeners"},{"location":"v1/4_events_and_listeners/#event-types","text":"Gkernel's events can be application level and request level (web request or CLI command).","title":"Event types"},{"location":"v1/4_events_and_listeners/#application-level-events","text":"Application level events are used to manage request-processing flow. There are next application level events:","title":"Application level events"},{"location":"v1/4_events_and_listeners/#applicationlaunched","text":"Is being dispatched after application started, and configured but before it started to listen it's port. Can be used to establish DB connection, cache warming, etc.","title":"ApplicationLaunched"},{"location":"v1/4_events_and_listeners/#applicationtermination","text":"Is being dispatched during application shut down process. Can be used to close DB connections, exporting of some cached data, etc. Application level events has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetContainer() *gioc.Container - returns DI Container object used by Application. Application level events has next attributes: Errors *[]error - slice of errors occurred during application shutdown process","title":"ApplicationTermination"},{"location":"v1/4_events_and_listeners/#request-level-events","text":"About request level events you can reed in corresponding sections: web and CLI .","title":"Request level events"},{"location":"v1/5-1_web_request_lifecycle/","text":"Web Request lifecycle Request processing cycle (also it can be called request lifecycle) has next main parts: Framework receives request and performs routing to determine controller for request processing. If required route not exists - framework creates NotFoundHttpError and dispatches RuntimeError event. RequestReceived event is being dispatched. If listeners for that event returned response object - framework goes to p.5. Controller starts. RequestProcessed event is being dispatched. ResponseBeforeSend event is being dispatched. Framework sends response to user. RequestTermination event is being dispatched. Notice: RequestTermination is dispatched in separate goroutine in order not to delay response sending to user. If some panic occurs during request processing framework recovers it and dispatches RuntimeError .","title":"Request lifecycle"},{"location":"v1/5-1_web_request_lifecycle/#web-request-lifecycle","text":"Request processing cycle (also it can be called request lifecycle) has next main parts: Framework receives request and performs routing to determine controller for request processing. If required route not exists - framework creates NotFoundHttpError and dispatches RuntimeError event. RequestReceived event is being dispatched. If listeners for that event returned response object - framework goes to p.5. Controller starts. RequestProcessed event is being dispatched. ResponseBeforeSend event is being dispatched. Framework sends response to user. RequestTermination event is being dispatched. Notice: RequestTermination is dispatched in separate goroutine in order not to delay response sending to user. If some panic occurs during request processing framework recovers it and dispatches RuntimeError .","title":"Web Request lifecycle"},{"location":"v1/5-2_web_request_and_response/","text":"HTTP web applications work in request-response mode and Gkernel uses certain objects to represent and work with that requests and responses. Request Gkernel uses standard net/http Request type to represent HTTP request received by a server. Response Response represents result of request processing that should be sent to user. Response can be of any type that implements next interface: type Response interface { GetHttpStatus() int GetHeaders() http.Header GetBodyBytes() *bytes.Buffer } Gkernel framework provides a bunch of ready to use Response types: BytesResponse Represents simples response - slices of bytes. BytesResponse has next fields: Body *bytes.Buffer - stores response bytes, that should be sent to user. BytesResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - intended to simplify adding new headers to response. You can call r.GetHeaders().Set(\"MyHeader\", \"my header value\") or just r.HeaderSet(\"MyHeader\", \"my header value\") func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) ClearBody() - removes old Body bytes buffer, creates new and empty func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer To create new BytesResponse you can use factory method NewBytesResponse() : import ( \"github.com/bassbeaver/gkernel/web/response\" ) responseObj := response.NewBytesResponse() BytesResponseWriter Is a simple wrapper around BytesResponse to use in case when you need to use Gkernel's BytesResponse as http.ResponseWriter . For example, adding pprof endpoints to Gkernel's routing: package main import ( webKernel \"github.com/bassbeaver/gkernel/web\" kernelResponse \"github.com/bassbeaver/gkernel/web/response\" \"net/http\" \"net/http/pprof\" ) ... kernelObj, kernelError := webKernel.NewKernel(\"/path/to/config\") if nil != kernelError { panic(kernelError) } ... registerPprofRoute := func(name, url string, handlerFunc http.HandlerFunc) { kernelObj.RegisterRoute(&webKernel.Route{ Name: name, Url: url, Methods: []string{http.MethodGet}, Controller: func(request *http.Request) kernelResponse.Response { w := kernelResponse.NewBytesResponseWriter() handlerFunc(w, request) return w }, }) } registerPprofRoute(\"pprof:index\", \"/debug/pprof/\", pprof.Index) registerPprofRoute(\"pprof:cmdline\", \"/debug/pprof/cmdline\", pprof.Cmdline) registerPprofRoute(\"pprof:profile\", \"/debug/pprof/profile\", pprof.Profile) registerPprofRoute(\"pprof:symbol\", \"/debug/pprof/profile\", pprof.Symbol) registerPprofRoute(\"pprof:trace\", \"/debug/pprof/trace\", pprof.Trace) registerPprofRoute(\"pprof:heap\", \"/debug/pprof/heap\", pprof.Index) RedirectResponse Represents response that should be sent to useragent to perform redirect. To create new BytesResponse you can use factory method: NewRedirectResponse(request *http.Request, url string, httpStatus int) *RedirectResponse Where: request is current Request object url - URL to redirect to httpStatus HTTP status to set for this response. As default status you can use http.StatusSeeOther (303) status. ViewResponse You can use ViewResponse when you need to return rendered template (usually html template). ViewResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - sets request's header value func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer func (r *ViewResponse) SetData(data interface{}) - sets template's data (variables used for templates rendering) func (r *ViewResponse) SetTemplate(tpl *template.Template) - is used with Gkernel and usually you do not need this method. In most cases, to return rendered template (view) as a Response you will be enough to use factory method: NewViewResponse(templateName string) *ViewResponse Example (from bassbeaver/gkernel-skeleton IndexController ): func (c *IndexController) PageWithParam(request *http.Request) kernelResponse.Response { var viewData struct { CsrfToken string User auth.UserInterface Header struct { Title string } H1 string Param string } viewData.Header.Title = \"gkernel skeleton site\" viewData.H1 = \"This is page with URL parameter\" viewData.CsrfToken = csrfService.GetTokenFromRequestContext(request) if auth.GetUser(request) != nil { viewData.User = auth.GetUser(request).(*user_provider.UserStub) } viewData.Param = request.URL.Query().Get(\":parameterValue\") response := kernelResponse.NewViewResponse(\"index/page-with-param.gohtml\") response.SetData(viewData) return response } Notice: templateName from NewViewResponse(templateName string) *ViewResponse is relative path to template file. Full path to template file Gkernel determines according to the following algorithm: <path to application Config file>/<templates_path>/<templateName> Where: <path to application Config file> - path to application's configuration file <templates_path> - value application's configuration file <templateName> - template's name from NewViewResponse(templateName string) factory method Access to Gkernels html/template object and registration of custom template functions To work with templates Gkernel uses html/template library. Templates parsing happens during templates during application startup after Gkernel's Run() method call. Sometimes you need access to template.Template object (to register custom template functions or make other configuration). Gkernel provides appropriate method GetTemplates() . Example of custom template functions registration: kernelObj, kernelError := webKernel.NewKernel(\"/path/to/config\") ... kernelObj.GetTemplates().Funcs(template.FuncMap{ \"sequence\": func(size int) []int { sequence := make([]int, size) for i := 0; i < size; i++ { sequence[i] = i } return sequence }, \"addInt\": func(a, b int) int { return a + b }, \"subInt\": func(a, b int) int { return a - b }, }) After that you can use these functions in templates: {{range $i := sequence $pagination.TotalPages}} {{$pageNum := addInt $i 1}} <a href=\"{{$pagination.CurrentUrl}}?page={{$pageNum}}\">{{$pageNum}}</a> {{end}} JsonResponse Represents json encoded response. JsonResponse has next fields: Body interface{} - response value, that should be json encoded and sent to user JsonResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - sets request's header value func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer To create new JsonResponse you can use factory method: NewJsonResponse() *JsonResponse this factory method sets Content-Type header to application/json for created Response object. Also, Gkernel provides factory method to create Json Api Response: NewJsonApiResponse() *JsonResponse It is similar to NewJsonResponse() except that sets Content-Type header to application/json . WebsocketUpgradeResponse Represents Response used to upgrade protocol to WebSocket. To create new WebsocketUpgradeResponse you can use factory method NewWebsocketUpgradeResponse(upgrader *websocket.Upgrader, controller WebSocketController) *WebsocketUpgradeResponse Where: upgrader - instance of gorilla/websocket.Upgrader controller - function with signature: func(*websocket.Conn)","title":"Request and Response"},{"location":"v1/5-2_web_request_and_response/#request","text":"Gkernel uses standard net/http Request type to represent HTTP request received by a server.","title":"Request"},{"location":"v1/5-2_web_request_and_response/#response","text":"Response represents result of request processing that should be sent to user. Response can be of any type that implements next interface: type Response interface { GetHttpStatus() int GetHeaders() http.Header GetBodyBytes() *bytes.Buffer } Gkernel framework provides a bunch of ready to use Response types:","title":"Response"},{"location":"v1/5-2_web_request_and_response/#bytesresponse","text":"Represents simples response - slices of bytes. BytesResponse has next fields: Body *bytes.Buffer - stores response bytes, that should be sent to user. BytesResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - intended to simplify adding new headers to response. You can call r.GetHeaders().Set(\"MyHeader\", \"my header value\") or just r.HeaderSet(\"MyHeader\", \"my header value\") func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) ClearBody() - removes old Body bytes buffer, creates new and empty func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer To create new BytesResponse you can use factory method NewBytesResponse() : import ( \"github.com/bassbeaver/gkernel/web/response\" ) responseObj := response.NewBytesResponse()","title":"BytesResponse"},{"location":"v1/5-2_web_request_and_response/#bytesresponsewriter","text":"Is a simple wrapper around BytesResponse to use in case when you need to use Gkernel's BytesResponse as http.ResponseWriter . For example, adding pprof endpoints to Gkernel's routing: package main import ( webKernel \"github.com/bassbeaver/gkernel/web\" kernelResponse \"github.com/bassbeaver/gkernel/web/response\" \"net/http\" \"net/http/pprof\" ) ... kernelObj, kernelError := webKernel.NewKernel(\"/path/to/config\") if nil != kernelError { panic(kernelError) } ... registerPprofRoute := func(name, url string, handlerFunc http.HandlerFunc) { kernelObj.RegisterRoute(&webKernel.Route{ Name: name, Url: url, Methods: []string{http.MethodGet}, Controller: func(request *http.Request) kernelResponse.Response { w := kernelResponse.NewBytesResponseWriter() handlerFunc(w, request) return w }, }) } registerPprofRoute(\"pprof:index\", \"/debug/pprof/\", pprof.Index) registerPprofRoute(\"pprof:cmdline\", \"/debug/pprof/cmdline\", pprof.Cmdline) registerPprofRoute(\"pprof:profile\", \"/debug/pprof/profile\", pprof.Profile) registerPprofRoute(\"pprof:symbol\", \"/debug/pprof/profile\", pprof.Symbol) registerPprofRoute(\"pprof:trace\", \"/debug/pprof/trace\", pprof.Trace) registerPprofRoute(\"pprof:heap\", \"/debug/pprof/heap\", pprof.Index)","title":"BytesResponseWriter"},{"location":"v1/5-2_web_request_and_response/#redirectresponse","text":"Represents response that should be sent to useragent to perform redirect. To create new BytesResponse you can use factory method: NewRedirectResponse(request *http.Request, url string, httpStatus int) *RedirectResponse Where: request is current Request object url - URL to redirect to httpStatus HTTP status to set for this response. As default status you can use http.StatusSeeOther (303) status.","title":"RedirectResponse"},{"location":"v1/5-2_web_request_and_response/#viewresponse","text":"You can use ViewResponse when you need to return rendered template (usually html template). ViewResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - sets request's header value func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer func (r *ViewResponse) SetData(data interface{}) - sets template's data (variables used for templates rendering) func (r *ViewResponse) SetTemplate(tpl *template.Template) - is used with Gkernel and usually you do not need this method. In most cases, to return rendered template (view) as a Response you will be enough to use factory method: NewViewResponse(templateName string) *ViewResponse Example (from bassbeaver/gkernel-skeleton IndexController ): func (c *IndexController) PageWithParam(request *http.Request) kernelResponse.Response { var viewData struct { CsrfToken string User auth.UserInterface Header struct { Title string } H1 string Param string } viewData.Header.Title = \"gkernel skeleton site\" viewData.H1 = \"This is page with URL parameter\" viewData.CsrfToken = csrfService.GetTokenFromRequestContext(request) if auth.GetUser(request) != nil { viewData.User = auth.GetUser(request).(*user_provider.UserStub) } viewData.Param = request.URL.Query().Get(\":parameterValue\") response := kernelResponse.NewViewResponse(\"index/page-with-param.gohtml\") response.SetData(viewData) return response } Notice: templateName from NewViewResponse(templateName string) *ViewResponse is relative path to template file. Full path to template file Gkernel determines according to the following algorithm: <path to application Config file>/<templates_path>/<templateName> Where: <path to application Config file> - path to application's configuration file <templates_path> - value application's configuration file <templateName> - template's name from NewViewResponse(templateName string) factory method","title":"ViewResponse"},{"location":"v1/5-2_web_request_and_response/#access-to-gkernels-htmltemplate-object-and-registration-of-custom-template-functions","text":"To work with templates Gkernel uses html/template library. Templates parsing happens during templates during application startup after Gkernel's Run() method call. Sometimes you need access to template.Template object (to register custom template functions or make other configuration). Gkernel provides appropriate method GetTemplates() . Example of custom template functions registration: kernelObj, kernelError := webKernel.NewKernel(\"/path/to/config\") ... kernelObj.GetTemplates().Funcs(template.FuncMap{ \"sequence\": func(size int) []int { sequence := make([]int, size) for i := 0; i < size; i++ { sequence[i] = i } return sequence }, \"addInt\": func(a, b int) int { return a + b }, \"subInt\": func(a, b int) int { return a - b }, }) After that you can use these functions in templates: {{range $i := sequence $pagination.TotalPages}} {{$pageNum := addInt $i 1}} <a href=\"{{$pagination.CurrentUrl}}?page={{$pageNum}}\">{{$pageNum}}</a> {{end}}","title":"Access to Gkernels html/template object and registration of custom template functions"},{"location":"v1/5-2_web_request_and_response/#jsonresponse","text":"Represents json encoded response. JsonResponse has next fields: Body interface{} - response value, that should be json encoded and sent to user JsonResponse has next methods: func (r *basicResponse) GetHeaders() http.Header func (r *basicResponse) HeaderSet(key, value string) - sets request's header value func (r *basicResponse) GetHttpStatus() int - returns response's HTTP status func (r *basicResponse) SetHttpStatus(status int) - sets response's HTTP status. func (r *BytesResponse) GetBodyBytes() *bytes.Buffer - returns a pointer to the Body bytes buffer To create new JsonResponse you can use factory method: NewJsonResponse() *JsonResponse this factory method sets Content-Type header to application/json for created Response object. Also, Gkernel provides factory method to create Json Api Response: NewJsonApiResponse() *JsonResponse It is similar to NewJsonResponse() except that sets Content-Type header to application/json .","title":"JsonResponse"},{"location":"v1/5-2_web_request_and_response/#websocketupgraderesponse","text":"Represents Response used to upgrade protocol to WebSocket. To create new WebsocketUpgradeResponse you can use factory method NewWebsocketUpgradeResponse(upgrader *websocket.Upgrader, controller WebSocketController) *WebsocketUpgradeResponse Where: upgrader - instance of gorilla/websocket.Upgrader controller - function with signature: func(*websocket.Conn)","title":"WebsocketUpgradeResponse"},{"location":"v1/5-3_web_routing_and_controllers/","text":"Routing Route determines connection between URL and Controller, designed to process requests to that URL. To represent Route in code, Gkernel provides Route type. Route has next fields: Name, string - name of the route Methods, []string - array of HTTP method names. Route will only process requests made using that methods. Url, string Controller, Controller - Controller to process request Main way to create routes in Gkernel application is to describe routes in Configuration file. This way is described in Configuration section of this documentation. But also, you can register routes within the code. Gkernel provides appropriate method for this: func (k *Kernel) RegisterRoute(route *Route) *Kernel Route URL parameters Sometimes you will need to capture segments of the URI within your route. To achieve this you have to declare rote with parameter in URL. Configuration file example for this case: IndexController:pageWithParam: url: \"/page-with-param/:parameterValue\" methods: [\"GET\"] controller: \"IndexController:PageWithParam\" Where declared parameter is :parameterValue . Captured parameters live in Request object. To obtain captured parameter inside controller you have to: import ( kernelResponse \"github.com/bassbeaver/gkernel/web/response\" \"net/http\" ) func (c *IndexController) PageWithParam(request *http.Request) kernelResponse.Response { ... urlParam := request.URL.Query().Get(\":parameterValue\") ... } Controller Basically Controller is function that receives request object and have to return response object. Controller function should have next signature: import ( kernelResponse \"github.com/bassbeaver/gkernel/web/response\" \"net/http\" ) func(*http.Request) kernelResponse.Response Gkernel's approach to Controllers is to register Service where some methods have appropriate (Controller's) signature.","title":"Routing and Controllers"},{"location":"v1/5-3_web_routing_and_controllers/#routing","text":"Route determines connection between URL and Controller, designed to process requests to that URL. To represent Route in code, Gkernel provides Route type. Route has next fields: Name, string - name of the route Methods, []string - array of HTTP method names. Route will only process requests made using that methods. Url, string Controller, Controller - Controller to process request Main way to create routes in Gkernel application is to describe routes in Configuration file. This way is described in Configuration section of this documentation. But also, you can register routes within the code. Gkernel provides appropriate method for this: func (k *Kernel) RegisterRoute(route *Route) *Kernel","title":"Routing"},{"location":"v1/5-3_web_routing_and_controllers/#route-url-parameters","text":"Sometimes you will need to capture segments of the URI within your route. To achieve this you have to declare rote with parameter in URL. Configuration file example for this case: IndexController:pageWithParam: url: \"/page-with-param/:parameterValue\" methods: [\"GET\"] controller: \"IndexController:PageWithParam\" Where declared parameter is :parameterValue . Captured parameters live in Request object. To obtain captured parameter inside controller you have to: import ( kernelResponse \"github.com/bassbeaver/gkernel/web/response\" \"net/http\" ) func (c *IndexController) PageWithParam(request *http.Request) kernelResponse.Response { ... urlParam := request.URL.Query().Get(\":parameterValue\") ... }","title":"Route URL parameters"},{"location":"v1/5-3_web_routing_and_controllers/#controller","text":"Basically Controller is function that receives request object and have to return response object. Controller function should have next signature: import ( kernelResponse \"github.com/bassbeaver/gkernel/web/response\" \"net/http\" ) func(*http.Request) kernelResponse.Response Gkernel's approach to Controllers is to register Service where some methods have appropriate (Controller's) signature.","title":"Controller"},{"location":"v1/5-4_web_events_and_listeners/","text":"There are next request level events dispatched by web Kernel of Gkernel framework: RequestReceived Is being dispatched after request was received by the framework but before it was passed to controller. Can be used to read user's session from the storage, for authentication & authorization, etc. RequestReceived Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially RequestReceived Event has no Response (method returns nil ) SetResponse(responseObj response.Response) - stops Event's propagation and sends provided Response to user. RequestProcessed Is being dispatched after Controller has processed Request. Contains Response object returned from Controller. RequestProcessed Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially this will be Response returned by Controller SetResponse(responseObj response.Response) - sets Response object. Notice: unlike RequestReceived.SetResponse() this method does not stop Event's propagation ResponseBeforeSend Is being dispatched after RequestProcessed Event was processed. Can modify Response but can not replace it with new object. ResponseBeforeSend Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object RequestTermination Is being dispatched after Response was sent to user. Can be used for logs exporting and others after-request activities. RequestTermination Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object GetResponse() response.Response - gets Response object RuntimeError In case of panic during Request processing Gkernel automatically recovers that panic, creates RuntimeError object to represent that panic and dispatches RuntimeError. RuntimeError Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially RuntimeError Event has no Response (method returns nil ) SetResponse(responseObj response.Response) - stops Event's propagation and sends provided Response to user. GetError() *kernelError.RuntimeError - returns RuntimeError object that represents recovered panic","title":"Events and Listeners"},{"location":"v1/5-4_web_events_and_listeners/#requestreceived","text":"Is being dispatched after request was received by the framework but before it was passed to controller. Can be used to read user's session from the storage, for authentication & authorization, etc. RequestReceived Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially RequestReceived Event has no Response (method returns nil ) SetResponse(responseObj response.Response) - stops Event's propagation and sends provided Response to user.","title":"RequestReceived"},{"location":"v1/5-4_web_events_and_listeners/#requestprocessed","text":"Is being dispatched after Controller has processed Request. Contains Response object returned from Controller. RequestProcessed Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially this will be Response returned by Controller SetResponse(responseObj response.Response) - sets Response object. Notice: unlike RequestReceived.SetResponse() this method does not stop Event's propagation","title":"RequestProcessed"},{"location":"v1/5-4_web_events_and_listeners/#responsebeforesend","text":"Is being dispatched after RequestProcessed Event was processed. Can modify Response but can not replace it with new object. ResponseBeforeSend Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object","title":"ResponseBeforeSend"},{"location":"v1/5-4_web_events_and_listeners/#requesttermination","text":"Is being dispatched after Response was sent to user. Can be used for logs exporting and others after-request activities. RequestTermination Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object GetResponse() response.Response - gets Response object","title":"RequestTermination"},{"location":"v1/5-4_web_events_and_listeners/#runtimeerror","text":"In case of panic during Request processing Gkernel automatically recovers that panic, creates RuntimeError object to represent that panic and dispatches RuntimeError. RuntimeError Event has next methods: StopPropagation() - to stop Event's propagation inside Listeners Chain IsPropagationStopped() bool - returns if propagation of Event was stopped GetRequest() *http.Request - returns Request object RequestContextAppend(key, val interface{}) - appends provided val object to Request's context GetResponseWriter() http.ResponseWriter - returns ResponseWriter object associated with current Request GetResponse() response.Response - gets Response object provided to this Event. Initially RuntimeError Event has no Response (method returns nil ) SetResponse(responseObj response.Response) - stops Event's propagation and sends provided Response to user. GetError() *kernelError.RuntimeError - returns RuntimeError object that represents recovered panic","title":"RuntimeError"},{"location":"v1/5-5_web_timeouts/","text":"Gkernel framework provides opportunities to configure HTTP server timeouts (ReadHeaderTimeout, ReadTimeout, WriteTimeout, IdleTimeout) and also to configure per-route timeouts. HTTP server timeouts HTTP server configuration is done by next config expressions: web: server_read_header_timeout: 2500 server_read_timeout: 7500 server_write_timeout: 15000 server_idle_timeout: 7500 Timeout values are in milliseconds Route timeouts As you know, server timeouts (ReadHeaderTimeout, ReadTimeout, WriteTimeout, IdleTimeout) mostly protects you from slow or malicious client, but server timeouts can not help you against your own slow code. If you have server_write_timeout is set to 15 seconds but your controller takes it up to 30 seconds for request processing client will wait 30 seconds and will get connection closed only when controller ends with processing. This is how server timeouts working. For time limiting of request processing we have to use route timeouts. When perroute timeout expires Gkernel framework stops waiting for request processing result and send timeout response to client. To configure route timeout next config expression is used: web: routing: routes: RouteName: timeout: duration: 10000 handler: \"TimeoutHandler:PerformLoginHandleTimeout\" Where timeout.duration is timeout in milliseconds and handler is handler function used to return timeout response. Basically timeout handler is function with signature: import ( kernelResponse \"github.com/bassbeaver/gkernel/web/response\" ) func() kernelResponse.Response Gkernel's approach to Timeout Handlers is to register Service where some method have appropriate (Timeout Handler's) signature. In configuration RouteName.timeout.handler clause value \"TimeoutHandler:PerformLoginHandleTimeout\" determines service ( TimeoutHandler ) and method of this service ( PerformLoginHandleTimeout ). Example of full config of route looks like: web: routing: routes: IndexController:performLogin: url: \"/login-perform\" methods: [\"POST\"] controller: \"IndexController:PerformLoginLogout\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectIfAuthenticated\", priority: 41} - {event: kernelEvent.RequestReceived, listener: \"AuthService:AuthenticateByLogPass\", priority: 42} timeout: duration: 10000 handler: \"TimeoutHandler:PerformLoginHandleTimeout\" Common route timeouts In section above we described how to set route timeout processing in route configuration but often it is not convenient to use if we want to use same timeout processing for multiple routes. For this case Gkernel framework provides common route timeout configuration. This common configuration applies to all routes which do not have \"personal\" configuration. Common route timeout config looks like: web: routing: timeout: duration: 8000 handler: \"TimeoutHandler:HandleTimeout\" Also, full example of timeouts configuration and usage you can see at gkernel skeleton application .","title":"Timeouts"},{"location":"v1/5-5_web_timeouts/#http-server-timeouts","text":"HTTP server configuration is done by next config expressions: web: server_read_header_timeout: 2500 server_read_timeout: 7500 server_write_timeout: 15000 server_idle_timeout: 7500 Timeout values are in milliseconds","title":"HTTP server timeouts"},{"location":"v1/5-5_web_timeouts/#route-timeouts","text":"As you know, server timeouts (ReadHeaderTimeout, ReadTimeout, WriteTimeout, IdleTimeout) mostly protects you from slow or malicious client, but server timeouts can not help you against your own slow code. If you have server_write_timeout is set to 15 seconds but your controller takes it up to 30 seconds for request processing client will wait 30 seconds and will get connection closed only when controller ends with processing. This is how server timeouts working. For time limiting of request processing we have to use route timeouts. When perroute timeout expires Gkernel framework stops waiting for request processing result and send timeout response to client. To configure route timeout next config expression is used: web: routing: routes: RouteName: timeout: duration: 10000 handler: \"TimeoutHandler:PerformLoginHandleTimeout\" Where timeout.duration is timeout in milliseconds and handler is handler function used to return timeout response. Basically timeout handler is function with signature: import ( kernelResponse \"github.com/bassbeaver/gkernel/web/response\" ) func() kernelResponse.Response Gkernel's approach to Timeout Handlers is to register Service where some method have appropriate (Timeout Handler's) signature. In configuration RouteName.timeout.handler clause value \"TimeoutHandler:PerformLoginHandleTimeout\" determines service ( TimeoutHandler ) and method of this service ( PerformLoginHandleTimeout ). Example of full config of route looks like: web: routing: routes: IndexController:performLogin: url: \"/login-perform\" methods: [\"POST\"] controller: \"IndexController:PerformLoginLogout\" event_listeners: - {event: kernelEvent.RequestReceived, listener: \"AuthService:RedirectIfAuthenticated\", priority: 41} - {event: kernelEvent.RequestReceived, listener: \"AuthService:AuthenticateByLogPass\", priority: 42} timeout: duration: 10000 handler: \"TimeoutHandler:PerformLoginHandleTimeout\"","title":"Route timeouts"},{"location":"v1/5-5_web_timeouts/#common-route-timeouts","text":"In section above we described how to set route timeout processing in route configuration but often it is not convenient to use if we want to use same timeout processing for multiple routes. For this case Gkernel framework provides common route timeout configuration. This common configuration applies to all routes which do not have \"personal\" configuration. Common route timeout config looks like: web: routing: timeout: duration: 8000 handler: \"TimeoutHandler:HandleTimeout\" Also, full example of timeouts configuration and usage you can see at gkernel skeleton application .","title":"Common route timeouts"},{"location":"v1/6-1_cli_command_lifecycle/","text":"CLI command lifecycle \"Incoming request\" for CLI environment we suggest to call Command. Command has simpler lifecycle then web and looks like: Framework parses incoming CLI arguments of program and determines the Command corresponding to these arguments. Command contains Controller to process this command. Framework starts this Controller and passes incoming CLI arguments to Controller. Controller completes request successfully or return error in case of failure.","title":"Command lifecycle"},{"location":"v1/6-1_cli_command_lifecycle/#cli-command-lifecycle","text":"\"Incoming request\" for CLI environment we suggest to call Command. Command has simpler lifecycle then web and looks like: Framework parses incoming CLI arguments of program and determines the Command corresponding to these arguments. Command contains Controller to process this command. Framework starts this Controller and passes incoming CLI arguments to Controller. Controller completes request successfully or return error in case of failure.","title":"CLI command lifecycle"},{"location":"v1/6-2_cli_command_and_controller/","text":"Command Gkernel provides Command type to represents incoming CLI command of the program. Command has next fields: Name, string - name of Command. Controller, Controller - Controller to process command Help, string - string for full command description shown when running the command with the --help option. help strings of all commands registered in CLI Kernel are returned by Kernel.Help() method. Controller Controller is function that receives incoming program CLI arguments and have to return CliError on failure or nil in case of success. Controller function should have next signature: import ( cliKernelError \"github.com/bassbeaver/gkernel/cli/error\" ) func(args []string) cliKernelError.CliError Gkernel's approach to Controllers is to register Service where some methods have appropriate (Controller's) signature.","title":"Command and Controllers"},{"location":"v1/6-2_cli_command_and_controller/#command","text":"Gkernel provides Command type to represents incoming CLI command of the program. Command has next fields: Name, string - name of Command. Controller, Controller - Controller to process command Help, string - string for full command description shown when running the command with the --help option. help strings of all commands registered in CLI Kernel are returned by Kernel.Help() method.","title":"Command"},{"location":"v1/6-2_cli_command_and_controller/#controller","text":"Controller is function that receives incoming program CLI arguments and have to return CliError on failure or nil in case of success. Controller function should have next signature: import ( cliKernelError \"github.com/bassbeaver/gkernel/cli/error\" ) func(args []string) cliKernelError.CliError Gkernel's approach to Controllers is to register Service where some methods have appropriate (Controller's) signature.","title":"Controller"},{"location":"v1/6-3_cli_events_and_listeners/","text":"For now CLI Kernel of Gkernel does not have \"command level\" events and listeners. Only \"application level\" event are dispatched for CLI environment.","title":"Events and Listeners"}]}